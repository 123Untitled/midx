
en fait je vais te preciser mon language.

Les param :nt :tr :gt :vl sont des parametre d'une track qui est implicite.

Mais dans l'arbre ces param sont regroupe dans un node special track.

class track : public node {
	node* trig;
	node* note;
	node* gate;
	node* velo;
};

Ou ca peut meme etre des vectors

class track : public node {
	vector<node*> trig;
	vector<node*> note;
	vector<node*> gate;
	vector<node*> velo;
};

donc quand on fait par exemple :

:tr 1 0 1 0 0 1 | :tr 1 0 0 1

Implicitement ca va creer 2 track et jouer les sequences en parallele.

toute les leaf sont directement ajouter comme sequence quand elle sont les une a la suite des autre.

Par exemple :tr 1 0 1 0 0 >< 0 0 1 1 1 1

Signifie track(:tr (crossfade [seq1] [seq2])

Mais il y a des choses bizarre qu'on ne peut soit pas faire soit ca n'a pas de sens :

Par exemple un crossfade entre 2 type de sequences

:nt A#3 B2 G >< :tr 1 0 1 0 0

Par contre un crossfade entre 2 track oui

bass = :nt A#3 B2 G :tr 1 0 0 0 1 1
synth :nt C#3 A2 D  Eb  :tr 1 1 0 1 0 1 1

result = &bass >< &synth

ou dans la meme assignation :

bass = :nt A#3 B2 G :tr 1 0 0 0 1 1 >< :nt C#3 A2 D  Eb  :tr 1 1 0 1 0 1 1

En fait quand il y a un :param juste apres l'operateur crossfade ou l'operateur parallele, implicitement ca dit de faire l'operation entre 2 tracks.

Par contre si il n'y a pas de param juste apres l'operateur mais que des valeurs, ca faire l'operation localement sur la sequence du :param precedent.

les ambiguites du parallele et crossfade | >< entre 2 types de sequence differente (note et trigger)
:tr 1 0 1 1  ><  :nt C#3 A2 D Eb

Si il y a un :param juste apres un operateur >< ou |
implicitement ca va creer une nouvelle track
Donc la ca donne :

track1 (:tr 1 0 1 1)  ><  track2 (:nt C#3 A2 D Eb)

Et si on ne defini pas :tr ou :nt sur une des 2 track, ca joue l'etat par default, donc trig = 0 et note = 60

Si par contre il n'y a pas de :param apres ces operateurs, ca opere sur la sequence elle meme :
:tr 1 0 1 1  ><  0 1 0 0

Maintenant il reste a definir cette syntaxe :

:tr 1 0 1 1 (:nt 60 68 64  >< :tr 1 1 1 1 0) :nt C#3 A2 D Eb 

Ca peut creer juste 4 tracks

track 1 (:tr 1 0 1 1)
track 2 (:nt 60 68 64)
><
track 3 (:tr 1 1 1 1 0)
track 4 (:nt C#3 A2 D Eb) 

Donc ca n'a pas d'incidence

Il reste des ambiguite encore :

Les references
Si implicitement un track est cree dans l'arbre a chaque assignation

On ne peut pas referencer qu'un type de sequence.

Par exemple:

bass = :tr 1 0 1 0 1 0
Va creer implicitement :nt :vl :gt pour la track.

Donc si on fait :

synth = :tr 1 0 0 0 &bass

Ca va referencer la track complete, donc synth va contenir 2 track et non etendre son param trigger avec le param trigger de bass

Chose qui est dommage

Et meme si on imagine un accessor comme &bass:tr

Finalement bass peux lui meme contenir plusieur track qui ont toute un param :tr

Ca peut etre interessant finalement d'ajouter tout les tr que contient bass

Mais si on reference juste l'identifier sans preciser le param
synth = :tr 1 0 0 0 &bass

Et bien il va y avoir 2 track dans synth ou autant qu'il y en a dans bass qui se retrouve dans synth.

Et je n'ai pas precise mais c'est sequenciel et non parallele dans ce cas

Ca va jouer la track1 :tr 1 0 0 0 puis sequencielement tout ce qu'il y a dans bass

Voila ca fait beaucoup d'informations.

Et il y a encore des ambiguite sur les operation arithmetique

une sequence :nt 50 60 48 69 * 2

Ca donne :nt 50 60 48 (69 * 2)

Mais qu'en est t il par exemple de &bass * 2

Il y a encore beaucoup d'ambiguites a resoudre.

Je peux omettre certain operateur pour l'instant.

En tout cas je dois trouver un maniere de parser ce language
